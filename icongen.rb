require 'bundler/inline'
require 'lucky_case/string'

gemfile(true) do
  source 'https://rubygems.org'
  gem 'optparse'
  gem 'fileutils'
  gem 'lucky_case'
  gem 'json'
  gem 'fastimage'
end

def parse_options(into: nil)
  option_parser = OptionParser.new do |opts|
    opts.on('--source VALUE', 'Folder path to convert') { |p| into[:source] = p }
    opts.on('--destination VALUE', 'PeaksCoreUI path') { |p| into[:destination] = p }

    opts.on('-h', '--help', 'Prints this help') {
      puts opts
      exit
    }
  end

  option_parser.parse!(into: into)
end

def validate(options)
  raise OptionParser::MissingArgument.new('Missing source. See help') if options[:source].nil?
  raise OptionParser::MissingArgument.new('Missing destination. See help') if options[:destination].nil?
end

def build_asset_contents_hash(filename)
    {
        images: [
            {
                filename: filename,
                idiom: "universal"
            }
        ],
        info: {
            author: "xcode",
            version: 1
        },
        properties: {
          "preserves-vector-representation": true
        }
    }
end

def build_folder_contents_hash()
  {
      info: {
          author: "xcode",
          version: 1
      }
  }
end

def write_folder_contents_hash_to(filepath)
  File.open(filepath, "w") do |f|
    hash = build_folder_contents_hash()
    f.write(JSON.pretty_generate(hash, {space_before: " "}) + "\n")
  end
end

def swift_case_name(filename)
    name = File.basename(filename.pascal_case, ".*")
    name[0] = name[0].downcase
    name
end

def image_width(filename)
    File.open(filename, "r") do |io|
        size = FastImage.size(io)
        size ? size[0] : nil
    end
end

def generate_icongen_swift_file_at(filepath, icons_by_size)
  File.open(filepath, "w") do |f|
    f.puts "// Autogenerated by icongen"
    f.puts "// https://github.com/denyscodes/icongen"
    f.puts ""
    f.puts "import UIKit"
    f.puts ""
    f.puts "extension UIImage {"

    icons_by_size.sort.each_with_index do |(width, names), index|
      enum_name = "ic#{width}"
      f.puts "    public enum #{enum_name}: String, CaseIterable {"
    
      names.sort.each do |case_name|
        f.puts "        case #{case_name}"
      end
    
      f.puts ""
      f.puts "        public func callAsFunction() -> UIImage {"
      f.puts "            .iconInPackage(name: rawValue, size: #{width}, bundle: .module)"
      f.puts "        }"
      f.puts "    }"
      f.puts "" unless index == icons_by_size.size - 1
    end

    f.puts "}"
    f.puts ""

    # Add SwiftUI preview exactly matching the style user provided
    f.puts "#if canImport(SwiftUI) && DEBUG"
    f.puts "import SwiftUI"
    f.puts ""
    f.puts "#Preview(\"Icons\") {"
    f.puts "    PeaksCoreUIModule.initialize("
    f.puts "        i18n: { key, _ in"
    f.puts "            key.rawValue"
    f.puts "        },"
    f.puts "        imageI18n: { key, bundle in"
    f.puts "            UIImage(named: key, in: bundle, compatibleWith: nil)"
    f.puts "        })"
    f.puts ""
    f.puts "    return ScrollView {"
    f.puts "        ForEach(Example.all(), id: \\.\id) { example in"
    f.puts "            SwiftUI.Text(example.title).bold().padding()"
    f.puts "            LazyVGrid("
    f.puts "                columns: [.init(.adaptive(minimum: CGFloat(example.iconSize), maximum: CGFloat(example.iconSize)))],"
    f.puts "                alignment: .leading"
    f.puts "            ) {"
    f.puts "                ForEach(example.icons) { iconExample in"
    f.puts "                    SwiftUI.Image(uiImage: iconExample.iconProvider())"
    f.puts "                }"
    f.puts "            }"
    f.puts "        }"
    f.puts "    }.padding()"
    f.puts "}"
    f.puts ""
    f.puts "private struct Example {"
    f.puts "    struct IconExample: Swift.Identifiable {"
    f.puts "        var id: String = UUID().uuidString"
    f.puts "        let iconProvider: () -> UIImage"
    f.puts "    }"
    f.puts ""
    f.puts "    let id = UUID().uuidString"
    f.puts ""
    f.puts "    let iconSize: Int"
    f.puts "    let icons: [IconExample]"
    f.puts ""
    f.puts "    var title: String { \"\\(iconSize) x \\(iconSize)\" }"
    f.puts ""
    f.puts "    static func all() -> [Example] {"
    f.puts "        ["
    icons_by_size.sort.each_with_index do |(width, _), idx|
      enum = "ic#{width}"
      f.puts "            Example(iconSize: #{width}, icons: UIImage.#{enum}.allCases.map { icon in"
      f.puts "                IconExample(iconProvider: {"
      f.puts "                    icon()"
      f.puts "                })"
      f.puts "            })#{',' unless idx == icons_by_size.size - 1}"
    end
    f.puts "        ]"
    f.puts "    }"
    f.puts "}"
    f.puts "#endif"
  end
end

def clear_existing_xcassets(destination)
  FileUtils.rm_rf(Dir["#{destination}/Sources/Resources/Images.xcassets/ic/*"])
end

def process_svg_files(source, destination)
  icons_by_size = Hash.new { |h, k| h[k] = [] }

  Dir.glob("*").sort_by(&:downcase).each do |filename|
    if File.directory?(filename)
      warn "❗️ #{filename}/ is a directory, skipping"
      next
    end

    unless File.extname(filename).downcase == ".svg"
      warn "❗️ #{filename} not processed, not SVG"
      next
    end

    width = image_width(filename)
    unless width
      warn "❗️ #{filename} has no width, skipping"
      next
    end

    swift_case = swift_case_name(filename)
    icons_by_size[width] << swift_case

    new_filename = "ic#{width}#{filename.pascal_case}"
    new_basename = File.basename(new_filename, ".*")
    imageset_dir = "#{destination}/Sources/Resources/Images.xcassets/ic/#{width}px/#{new_basename}.imageset"

    FileUtils.mkdir_p(imageset_dir)
    FileUtils.cp(filename, "#{imageset_dir}/#{new_filename}")

    File.open("#{imageset_dir}/Contents.json", "w") do |f|
      hash = build_asset_contents_hash(new_filename)
      f.write(JSON.pretty_generate(hash, { space_before: " " }) + "\n")
    end
  end

  icons_by_size
end

options = {
  source: nil,
  destination: nil
}
parse_options(into: options)
validate(options)

# Set directory to source
Dir.chdir(options[:source])

# Clear existing icons xcassets
clear_existing_xcassets(options[:destination])

# Create new xcassets and return swift names grouped by size
icons_by_size = Hash.new { |h, k| h[k] = [] }
icons_by_size = process_svg_files(options[:source], options[:destination])

# Create Contents.json at /ic/Contents.json
write_folder_contents_hash_to("#{options[:destination]}/Sources/Resources/Images.xcassets/ic/Contents.json")

# Create Contents.json at /ic/icXpx/Contents.json
icons_by_size.each do |width, _|
    write_folder_contents_hash_to("#{options[:destination]}/Sources/Resources/Images.xcassets/ic/#{width}px/Contents.json")
end

# Generate UIImage+IconGen.swift
generate_icongen_swift_file_at("#{options[:destination]}/Sources/Extensions/UIImage+IconGen.swift", icons_by_size)